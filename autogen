#!/usr/bin/env python2
# This file is part of endian-ci, a simple sanity check of portable-endian.h
# Copyright 2016 Ben Wiederhake
# License: MIT, see LICENSE

# Please note that you only need to run this file if you changed it.
# Thus, your test system does *NOT* need to support Python.

from collections import OrderedDict


def ordered(d):
    # https://docs.python.org/2/library/collections.html#collections.OrderedDict
    # Why doesn't this exist as a standard function or smething?  Sigh.
    return OrderedDict(sorted(d.items(), key=lambda t: t[0]))

# ----------------
# Options.  Feel free to add your own!  :-)

compilers = ordered({
    'clang': '${CLANG} -Weverything -Werror -pedantic -O2 -g',
    'gcc': '${GCC} -Wall -Wextra -Werror -pedantic -O2 -g',
    'tcc': '${TCC} -Wall -Werror -g'})
languages_gnu = ordered({
    l: ("-std=%s" % l) for l in ['c89', 'gnu89', 'c99', 'gnu99', 'c11']})
languages = {'gcc': languages_gnu, 'clang': languages_gnu, 'tcc': {'std': ''}}
integers = ordered({
    'allint': [],
    'noint64': ['PORTABLE_ENDIAN_NO_UINT_64_T']})
modes = ordered({
    'noflags': [],
    'inline': ['PORTABLE_ENDIAN_MODIFIERS="static inline"'],
    'defhere': ['PORTABLE_ENDIAN_MODIFIERS='],
    'defext': ['PORTABLE_ENDIAN_MODIFIERS=', 'PORTABLE_ENDIAN_DECLS_ONLY']})
# Notes to 'flags':
# 'link-out': This, and only this value is used to prefix the object-arg,
#     so unixoid systems will need a space at the end
# 'linker': This has the special interpretation for 'None' that means
#     "Just re-use compiler[c] instead."
flags_unix = {'compile-only': '-c', 'def-macro': '-D', 'compile-out': '-o ',
              'linker': None, 'link-out': '-o '}
flags = {'clang': flags_unix, 'gcc': flags_unix, 'tcc': flags_unix}

# This must hold, no matter what your inputs.
assert all([flags.values()[0].viewkeys() == flags[c].viewkeys()
            for c in compilers])


# ----------------
# String construction (atoms) and globally cached objects

bin_format = 'bin/%s-%s-%s-%s${FILE_EXT}'

def obj_of(row, name, check=True):
    obj = 'obj/' + name + "_" + '-'.join(row) + ".o"
    if check and obj not in all_objs:
        print "Unknown object: " + obj
        assert False
    return obj


def wrap_macros(c, macros):
    def_macro = flags[c]['def-macro']
    return [def_macro + m for m in macros]


# Order is important, as globals are evaluated as soon as they are read,
# so 'obj_of' needs to be already defined.
all_rows = list([(c, l, i, m)
                 for c in compilers
                 for l in languages[c]
                 for i in integers
                 for m in modes])
all_objs = {obj_of(row, 'test', check=False) for row in all_rows}
all_objs = all_objs.union({obj_of((c, l, i, 'defhere'), 'lib', check=False)
                           for (c, l, i, _) in all_rows})


def body_compile(row, src, obj):
    c, l, i, m = row
    dst_argv = [compilers[c], languages[c][l]] + \
        wrap_macros(c, integers[i]) + \
        wrap_macros(c, modes[m]) + \
        [flags[c]['compile-only'], flags[c]['compile-out'] + obj, src]
    return " ".join(dst_argv)


def body_link(row, objs):
    c, _, _, _ = row
    linker = flags[c]['linker']
    if linker is None:
        linker = compilers[c]
    out = flags[c]['link-out'] + bin_format % row
    return " ".join([linker, out] + objs)


# Hint: This is probably ideal for testing your changes interactively.
# Unless, of course, you're fiddling with the compatibility logic.
# In that case, see below.
def base_body(row, joiner):
    c, l, i, m = row
    cmds = []
    objs = []
    if (m == 'defext'):
        obj = obj_of((c, l, i, 'defhere'), 'lib')
        cmd = body_compile((c, l, i, 'defhere'), 'as-static-lib.c', obj)
        objs.append(obj)
        cmds.append(cmd)
    test_obj = obj_of(row, 'test')
    objs.append(test_obj)
    cmds += [body_compile(row, 'test-functionality.c', test_obj)]
    cmds += [body_link(row, objs)]
    return joiner.join(cmds)


# ----------------
# String construction and output:  successful case

def base_body_success(row, joiner):
    return joiner.join([base_body(row, joiner),
                        # Otherwise, imagine the line " => fail (BAD)"
                        'echo " => success (GOOD, matches documentation)"'])


def gen_test_success(row):
    print '\t@' + base_body_success(row, '\n\t@')


# ----------------
# String construction and output:  failure case

def base_body_fail(row, indent):
    fmt = ('\n' + indent).join([
        'if \\',
        '\t%s > /dev/null 2>&1 ; \\',
        'then \\',
        '\techo " => success (BAD, doesn\'t match documentation!)" ; \\',
        '\texit 1 ; \\',
        'else \\',
        '\techo " => fail (GOOD, matches documentation)" ; \\',
        'fi'])
    joiner = '''> /dev/null 2>&1 && \\
%s\t''' % indent
    return fmt % base_body(row, joiner)


def gen_test_fail(row):
    print '\t@' + base_body_fail(row, '\t')


# ----------------
# Output:  "depends on platform" case
# Note that there is no stand-alone string construction for this because YAGNI.

def gen_test_maybe(row, test):
    fmt = \
'''\t@if %s ; \\
\tthen \\
\t\t%s ; \\
\telse \\
\t\t%s ; \\
\tfi'''
    print fmt % (test,
                 base_body_success(row, ' && \\\n\t\t'),
                 base_body_fail(row, '\t\t'))


# ----------------
# Main "compatibility logic".  Return-by-print is evil, but in this case
# it's the simplest solution, and it works reliable, easy, and fast.

def gen_rule_body(row):
    c, l, i, m = row
    apple_test = "${GCC} --version 2>/dev/null | grep -qc '^Apple.*clang'"
    c11_test = "${GCC} -std=c11 --target-help >/dev/null 2>&1 || " + apple_test
    if l == 'c89' and m == 'inline':
        # 'inline' is not a keyword in C89:
        return gen_test_fail(row)
    if l == 'gnu89' and m == 'inline':
        if c == 'clang':
            # clang thinks that 'inline' isn't a keyword in gnu89
            return gen_test_fail(row)
        if c == 'gcc':
            # On Apple, both binaries are actually clang
            return gen_test_maybe(row, "! " + apple_test)
        assert False  # You failed to synchronize stuff!
    if l == 'c11' and c == 'gcc':
        # Older versions of gcc don't support C11
        return gen_test_maybe(row, c11_test)
    gen_test_success(row)


def gen_rule_head(row):
    c, l, i, m = row
    bin_file = bin_format % row
    # That initial line break is intentional.
    head_format = '''
%s: test-functionality.c%s \\
\t\tportable-endian/portable-endian.h'''
    print head_format % \
        (bin_file, ' as-static-lib.c' if m == 'defext' else '')


# ----------------
# High-level but boring combination of all previous things.

def gen_rule(row):
    gen_rule_head(row)
    print '\t@echo "Building %s ..."' % (bin_format % row)
    gen_rule_body(row)


def gen_all_rules():
    for row in all_rows:
        gen_rule(row)


def gen_makefile():
    all_objs_str = " ".join(all_objs)
    blinding = "OGEN"  # Make sure this file doesn't say AUTOG--ENERATED
    # Ugly, but not really preventable.
    print \
'''# This file is part of endian-ci, a simple sanity check of portable-endian.h
# DO NOT MODIFY!  THIS FILE IS AUT%sERATED FROM autogen.py!
# Copyright 2016 Ben Wiederhake
# License: MIT, see LICENSE

FILE_EXT    ?=
GCC         ?= gcc
CLANG       ?= clang
TCC         ?= tcc

all: build-all run-existing

.PHONY: gen_makefile
gen_makefile: autogen
\t@echo "Overwriting Makefile by explicit request."
\t@echo "I hope you know what you're doing!"
\t./autogen > Makefile.tmp && mv -f Makefile.tmp Makefile

ALL_OBJS := %s

.PHONY: run-existing
run-existing:
\t@for i in ${ALL_BINS}; \\
\tdo \\
\t\tif test -x $$i ; \\
\t\tthen \\
\t\t\techo "Running test $$i:" ; \\
\t\t\t$$i || exit 1 ; \\
\t\telse \\
\t\t\techo "Running test $$i: SKIPPED, didn't build" ; \\
\t\tfi \\
\tdone

portable-endian/portable-endian.h:
\t@echo "portable-endian/portable-endian.h not found."
\t@echo "Did you checkout the submodule?  Try this:"
\t@echo "git submodule update --init"
\t@exit 1

.PHONY: clean
clean:
\t@echo 'rm -f $${ALL_BINS} $${ALL_OBJS}'
\t@rm -f ${ALL_BINS} ${ALL_OBJS}
\tls bin
\tls obj
\t@echo "End of 'clean'"''' % \
        (blinding, all_objs_str)
    for c in compilers:
        c_bins = [bin_format % row for row in all_rows if row[0]==c]
        # That initial line break is intentional.
        print '''
%s_BINS := %s
.PHONY: build-%s-only
build-%s-only: ${%s_BINS}''' % (c.upper(), ' '.join(c_bins), c, c, c.upper())
    # That initial line break is intentional.
    print '\nALL_BINS := ' + ' '.join(["${%s_BINS}" % c.upper() for c in compilers])
    print 'build-all: ${ALL_BINS}'
    gen_all_rules()


if __name__ == '__main__':
    gen_makefile()
